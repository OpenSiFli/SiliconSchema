#!/usr/bin/env python3
"""Build series.yaml files by merging chip.yaml with shared pinmux definitions."""

import argparse
import re
import sys
from pathlib import Path

import git
import yaml


def find_project_root() -> Path:
    """Find the SiliconSchema project root directory."""
    current = Path(__file__).resolve()
    for parent in current.parents:
        if (parent / "common" / "pinmux").exists():
            return parent
    raise RuntimeError("Could not find SiliconSchema project root")


def load_yaml(path: Path) -> dict:
    """Load a YAML file."""
    with open(path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)


def get_git_hash() -> str:
    """Get current git commit hash."""
    try:
        repo = git.Repo(find_project_root())
        return repo.head.commit.hexsha[:12]
    except Exception:
        return 'main'


def bits_to_field_index(bits: list[int]) -> int:
    """Convert bit range to PINR field index.
    
    [5, 0] -> 0, [13, 8] -> 1, [21, 16] -> 2, [29, 24] -> 3
    """
    low_bit = bits[1]
    return low_bit // 8


def build_pinr_lookup(pinr_data: dict) -> dict:
    """Build lookup table: signal_name -> (offset, field_index)."""
    lookup = {}
    registers = pinr_data.get('registers', {})
    
    for reg_name, reg_info in registers.items():
        offset = reg_info['offset']
        fields = reg_info.get('fields', {})
        
        base_match = re.match(r'^(\w+?)_?PINR\d?$', reg_name)
        if base_match:
            base_name = base_match.group(1)
        else:
            continue
        
        for field_name, field_info in fields.items():
            bits = field_info['bits']
            field_idx = bits_to_field_index(bits)
            
            if '_' in field_name:
                signal_name = field_name
            else:
                signal_name = f"{base_name}_{field_name}"
            
            lookup[signal_name] = (offset, field_idx)
    
    return lookup


def expand_pinr_functions(function: str, pinr_data: dict) -> list[str]:
    """Expand a generic function (I2C, UART, TIM) to specific signals."""
    peripherals = pinr_data.get('peripherals', {})
    expanded = []
    
    if function == 'I2C' and 'I2C' in peripherals:
        periph = peripherals['I2C']
        for instance in periph.get('instances', []):
            for signal in periph.get('signals', []):
                expanded.append(f"{instance}_{signal}")
    
    elif function == 'UART' and 'UART' in peripherals:
        periph = peripherals['UART']
        for instance in periph.get('instances', []):
            for signal in periph.get('signals', []):
                expanded.append(f"{instance}_{signal}")
    
    elif function == 'TIM' and 'TIM' in peripherals:
        periph = peripherals['TIM']
        signals_by_instance = periph.get('signals_by_instance', {})
        for instance in periph.get('instances', []):
            signals = signals_by_instance.get(instance, [])
            for signal in signals:
                expanded.append(f"{instance}_{signal}")
    
    return expanded


def generate_pinctrl_header(model_id: str, pinmux_data: dict, pinr_data: dict) -> str:
    """Generate Zephyr pinctrl header file content."""
    lines = []
    
    lines.append("/*")
    lines.append(" * Copyright (c) 2025 SiFli Technologies(Nanjing) Co., Ltd")
    lines.append(" * SPDX-License-Identifier: Apache-2.0")
    lines.append(" *")
    git_hash = get_git_hash()
    lines.append(f" * Auto-generated by <https://github.com/OpenSiFli/SiliconSchema/blob/{git_hash}/src/silicon_schema/build.py>")
    lines.append(" */")
    lines.append("")
    guard = f"_INCLUDE_ZEPHYR_DT_BINDINGS_PINCTRL_{model_id.upper()}_PINCTRL_H_"
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}")
    lines.append("")
    lines.append('#include "sf32lb-common-pinctrl.h"')
    lines.append("")
    
    lines.append("/* ports */")
    lines.append("#define SF32LB_PORT_SA 0U")
    lines.append("#define SF32LB_PORT_PA 1U")
    lines.append("")
    
    pinr_lookup = build_pinr_lookup(pinr_data)
    pinmux_map = pinmux_data.get('pinmux', {})
    
    for pad_name, entries in pinmux_map.items():
        match = re.match(r'^(PA|SA)(\d+)$', pad_name)
        if not match:
            continue
        
        port = match.group(1)
        pad_num = int(match.group(2))
        
        lines.append(f"/* {pad_name} */")
        lines.append(f"#define {pad_name}_ANALOG".ljust(32) + f"SF32LB_PINMUX_ANALOG({port}, {pad_num}U)")
        
        if port == 'PA':
            lines.append(f"#define {pad_name}_GPIO".ljust(32) + f"SF32LB_PINMUX({port}, {pad_num}U, 0U, 0U, 0U)")
        
        for entry in entries:
            func = entry['function']
            select = entry['select']
            has_pinr = entry.get('pinr', False)
            
            if has_pinr:
                expanded = expand_pinr_functions(func, pinr_data)
                for exp_func in expanded:
                    if exp_func in pinr_lookup:
                        offset, field_idx = pinr_lookup[exp_func]
                        macro_name = f"{pad_name}_{exp_func}"
                        lines.append(f"#define {macro_name}".ljust(32) + 
                                   f"SF32LB_PINMUX({port}, {pad_num}U, {select}U, 0x{offset:02X}U, {field_idx}U)")
            else:
                if func.startswith('GPIO_'):
                    continue
                macro_name = f"{pad_name}_{func}"
                lines.append(f"#define {macro_name}".ljust(32) + 
                           f"SF32LB_PINMUX({port}, {pad_num}U, {select}U, 0U, 0U)")
        
        lines.append("")
    
    lines.append(f"#endif /* {guard} */")
    lines.append("")
    
    return '\n'.join(lines)


class YamlBuilder:
    """Helper class to build YAML with proper formatting."""
    
    def __init__(self, indent: int = 2):
        self.lines: list[str] = []
        self.indent = indent
    
    def add(self, line: str, level: int = 0) -> None:
        self.lines.append(' ' * (level * self.indent) + line)
    
    def add_blank(self) -> None:
        self.lines.append('')
    
    def build(self) -> str:
        return '\n'.join(self.lines)


def generate_series_yaml(chip_yaml: dict, pinmux_data: dict, pinr_data: dict) -> str:
    """Generate series.yaml content with YAML anchors and aliases."""
    
    b = YamlBuilder()
    
    # Header
    b.add(f"schema_version: {chip_yaml['schema_version']}")
    b.add(f"model_id: {chip_yaml['model_id']}")
    b.add(f"lifecycle: {chip_yaml['lifecycle']}")
    b.add_blank()
    
    # Docs
    b.add("docs:")
    for doc in chip_yaml['docs']:
        for doc_type, locales in doc.items():
            locale_parts = [f'{lang}: "{url}"' for lang, url in locales.items()]
            b.add(f"- {doc_type}: {{{', '.join(locale_parts)}}}", 1)
    b.add_blank()
    
    # Pads
    b.add("pads:")
    pinmux_map = pinmux_data.get('pinmux', {})
    
    for pad_name, pad_def in chip_yaml['pads'].items():
        b.add(f"{pad_name}: &{pad_name}", 1)
        b.add(f"type: {pad_def['type']}", 2)
        
        if 'description' in pad_def:
            b.add(f'description: "{pad_def["description"]}"', 2)
        if 'notes' in pad_def:
            b.add(f'notes: "{pad_def["notes"]}"', 2)
        
        if pad_name in pinmux_map:
            b.add("functions:", 2)
            for entry in pinmux_map[pad_name]:
                func = entry['function']
                has_pinr = entry.get('pinr', False)
                
                if has_pinr and pinr_data:
                    for exp_func in expand_pinr_functions(func, pinr_data):
                        b.add(f"- {exp_func}", 3)
                else:
                    b.add(f"- {func}", 3)
    b.add_blank()
    
    # Variants
    b.add("variants:")
    model_id = chip_yaml['model_id']
    used_anchors: set[str] = set()
    pins_anchor_by_key: dict[tuple[tuple[str, str], ...], str] = {}

    def sanitize_anchor(text: str) -> str:
        text = re.sub(r'[^A-Za-z0-9]+', '_', text or '')
        return text.strip('_') or 'PINS'

    for variant in chip_yaml['variants']:
        b.add(f"- part_number: {variant['part_number']}", 1)
        b.add(f'description: "{variant["description"]}"', 2)
        b.add(f"package: {variant['package']}", 2)

        pins = variant.get('pins', [])
        key = tuple((str(pin['number']), str(pin['pad'])) for pin in pins)

        anchor = pins_anchor_by_key.get(key)
        if anchor is None:
            anchor = f"{model_id}_{sanitize_anchor(variant.get('package', ''))}_{sanitize_anchor(variant['part_number'])}_PINS"
            while anchor in used_anchors:
                anchor = f"{anchor}_X"
            used_anchors.add(anchor)
            pins_anchor_by_key[key] = anchor

            b.add(f"pins: &{anchor}", 2)
            for pin in pins:
                pad_name = pin['pad']
                b.add(f'- {{number: "{pin["number"]}", pad: *{pad_name}}}', 3)
        else:
            b.add(f"pins: *{anchor}", 2)
        b.add_blank()
    
    return b.build()


def build_chip(chip_dir: Path, pinmux_dir: Path, output_dir: Path) -> bool:
    """Build series.yaml and pinctrl header for a single chip."""
    chip_yaml_path = chip_dir / "chip.yaml"
    series_yaml_path = output_dir / chip_dir.name / "series.yaml"
    
    if not chip_yaml_path.exists():
        print(f"  Skipping {chip_dir.name}: no chip.yaml found")
        return True
    
    print(f"  Building {chip_dir.name}...")
    
    chip_data = load_yaml(chip_yaml_path)
    model_id = chip_data.get('model_id', chip_dir.name)
    
    pinmux_data = {}
    pinr_data = {}
    pinmux_name = None
    if 'shared_pinmux' in chip_data:
        pinmux_name = chip_data['shared_pinmux']
        pinmux_path = pinmux_dir / pinmux_name / "pinmux.yaml"
        pinr_path = pinmux_dir / pinmux_name / "pinr.yaml"
        
        if pinmux_path.exists():
            pinmux_data = load_yaml(pinmux_path)
            print(f"    Loaded shared pinmux: {pinmux_name}")
        else:
            print(f"    Warning: shared pinmux '{pinmux_name}' not found at {pinmux_path}")
        
        if pinr_path.exists():
            pinr_data = load_yaml(pinr_path)
            print(f"    Loaded PINR definitions: {pinmux_name}")
    
    # Generate series.yaml
    series_content = generate_series_yaml(chip_data, pinmux_data, pinr_data)
    with open(series_yaml_path, 'w', encoding='utf-8') as f:
        f.write(series_content)
    print(f"    Generated: {series_yaml_path}")
    
    # Generate Zephyr pinctrl header (optional)
    header_filename = f"{model_id.lower()}-pinctrl.h"
    header_path = output_dir / chip_dir.name / header_filename

    skip_pinctrl_for_pinmux = {"sf32lb56", "sf32lb58"}
    generate_pinctrl = pinmux_name not in skip_pinctrl_for_pinmux

    if generate_pinctrl:
        header_content = generate_pinctrl_header(model_id, pinmux_data, pinr_data)
        with open(header_path, 'w', encoding='utf-8') as f:
            f.write(header_content)
        print(f"    Generated: {header_path}")
    else:
        if header_path.exists():
            header_path.unlink()
        print(f"    Skipped: pinctrl header not generated for {pinmux_name}")
    
    return True


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Build series.yaml files from chip.yaml and shared pinmux definitions"
    )
    parser.add_argument(
        "--chip", "-c",
        help="Build only the specified chip (directory name under chips/)",
        default=None
    )
    args = parser.parse_args()
    
    try:
        root = find_project_root()
    except RuntimeError as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1
    
    chips_dir = root / "chips"
    pinmux_dir = root / "common" / "pinmux"
    output_dir = root / "out"
    
    print("SiliconSchema Build")
    print(f"  Project root: {root}")
    print(f"  Chips directory: {chips_dir}")
    print(f"  Pinmux directory: {pinmux_dir}")
    print(f"  Output directory: {output_dir}")
    print()
    
    success = True
    
    if args.chip:
        chip_dir = chips_dir / args.chip
        if not chip_dir.exists():
            print(f"Error: chip directory '{args.chip}' not found", file=sys.stderr)
            return 1
        (output_dir / args.chip).mkdir(parents=True, exist_ok=True)
        success = build_chip(chip_dir, pinmux_dir, output_dir)
    else:
        print("Building all chips...")
        for chip_dir in sorted(chips_dir.iterdir()):
            if chip_dir.is_dir():
                (output_dir / chip_dir.name).mkdir(parents=True, exist_ok=True)
                if not build_chip(chip_dir, pinmux_dir, output_dir):
                    success = False
    
    print()
    if success:
        print("Build completed successfully!")
        return 0
    else:
        print("Build completed with errors.")
        return 1


if __name__ == "__main__":
    sys.exit(main())
