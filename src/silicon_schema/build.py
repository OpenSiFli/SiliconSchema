#!/usr/bin/env python3
"""Build series.yaml files by merging chip.yaml with shared pinmux definitions."""

import argparse
import re
import sys
from pathlib import Path

import yaml


def find_project_root() -> Path:
    """Find the SiliconSchema project root directory."""
    current = Path(__file__).resolve()
    for parent in current.parents:
        if (parent / "common" / "pinmux").exists():
            return parent
    raise RuntimeError("Could not find SiliconSchema project root")


def load_yaml(path: Path) -> dict:
    """Load a YAML file."""
    with open(path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f)


def bits_to_field_index(bits: list[int]) -> int:
    """Convert bit range to PINR field index.
    
    [5, 0] -> 0, [13, 8] -> 1, [21, 16] -> 2, [29, 24] -> 3
    """
    low_bit = bits[1]
    return low_bit // 8


def build_pinr_lookup(pinr_data: dict) -> dict:
    """Build lookup table: signal_name -> (offset, field_index).
    
    Returns dict like:
    {
        'I2C1_SDA': (0x48, 1),
        'I2C1_SCL': (0x48, 0),
        'USART1_TXD': (0x58, 0),
        ...
    }
    """
    lookup = {}
    registers = pinr_data.get('registers', {})
    
    for reg_name, reg_info in registers.items():
        offset = reg_info['offset']
        fields = reg_info.get('fields', {})
        
        # Extract base instance name (e.g., I2C1 from I2C1_PINR)
        base_match = re.match(r'^(\w+?)_?PINR\d?$', reg_name)
        if base_match:
            base_name = base_match.group(1)
        else:
            continue
        
        for field_name, field_info in fields.items():
            bits = field_info['bits']
            field_idx = bits_to_field_index(bits)
            
            # Handle special cases like ETR_PINR with GPTIM1_ETR, GPTIM2_ETR
            if '_' in field_name:
                # Field already contains full name (e.g., GPTIM1_ETR)
                signal_name = field_name
            else:
                # Build signal name (e.g., I2C1 + SDA -> I2C1_SDA)
                signal_name = f"{base_name}_{field_name}"
            
            lookup[signal_name] = (offset, field_idx)
    
    return lookup


def expand_pinr_functions(function: str, pinr_data: dict) -> list[str]:
    """Expand a generic function (I2C, UART, TIM) to specific signals.
    
    Returns a list of expanded function names like:
    - I2C -> [I2C1_SDA, I2C1_SCL, I2C2_SDA, I2C2_SCL, ...]
    - UART -> [USART1_TXD, USART1_RXD, USART1_CTS, USART1_RTS, ...]
    - TIM -> [GPTIM1_CH1, GPTIM1_CH2, ..., ATIM1_CH1, ...]
    """
    peripherals = pinr_data.get('peripherals', {})
    expanded = []
    
    if function == 'I2C' and 'I2C' in peripherals:
        periph = peripherals['I2C']
        for instance in periph.get('instances', []):
            for signal in periph.get('signals', []):
                expanded.append(f"{instance}_{signal}")
    
    elif function == 'UART' and 'UART' in peripherals:
        periph = peripherals['UART']
        for instance in periph.get('instances', []):
            for signal in periph.get('signals', []):
                expanded.append(f"{instance}_{signal}")
    
    elif function == 'TIM' and 'TIM' in peripherals:
        periph = peripherals['TIM']
        signals_by_instance = periph.get('signals_by_instance', {})
        for instance in periph.get('instances', []):
            signals = signals_by_instance.get(instance, [])
            for signal in signals:
                expanded.append(f"{instance}_{signal}")
    
    return expanded


def generate_pinctrl_header(model_id: str, pinmux_data: dict, pinr_data: dict) -> str:
    """Generate Zephyr pinctrl header file content."""
    lines = []
    
    # Header
    lines.append("/*")
    lines.append(" * Copyright (c) 2025 SiFli, Inc.")
    lines.append(" * SPDX-License-Identifier: Apache-2.0")
    lines.append(" *")
    lines.append(" * Auto-generated by SiliconSchema build system")
    lines.append(" */")
    lines.append("")
    guard = f"_INCLUDE_ZEPHYR_DT_BINDINGS_PINCTRL_{model_id.upper()}_PINCTRL_H_"
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}")
    lines.append("")
    lines.append('#include "sf32lb-common-pinctrl.h"')
    lines.append("")
    
    # Port definitions
    lines.append("/* ports */")
    lines.append("#define SF32LB_PORT_SA 0U")
    lines.append("#define SF32LB_PORT_PA 1U")
    lines.append("")
    
    # Build PINR lookup
    pinr_lookup = build_pinr_lookup(pinr_data)
    
    # Process pads
    pinmux_map = pinmux_data.get('pinmux', {})
    
    for pad_name, entries in pinmux_map.items():
        # Parse port and pad number
        match = re.match(r'^(PA|SA)(\d+)$', pad_name)
        if not match:
            continue
        
        port = match.group(1)
        pad_num = int(match.group(2))
        
        lines.append(f"/* {pad_name} */")
        
        # ANALOG
        lines.append(f"#define {pad_name}_ANALOG".ljust(32) + f"SF32LB_PINMUX_ANALOG({port}, {pad_num}U)")
        
        # GPIO (for PA port only)
        if port == 'PA':
            lines.append(f"#define {pad_name}_GPIO".ljust(32) + f"SF32LB_PINMUX({port}, {pad_num}U, 0U, 0U, 0U)")
        
        # Process functions
        for entry in entries:
            func = entry['function']
            select = entry['select']
            has_pinr = entry.get('pinr', False)
            
            if has_pinr:
                # Expand to specific signals with PINR routing
                expanded = expand_pinr_functions(func, pinr_data)
                for exp_func in expanded:
                    if exp_func in pinr_lookup:
                        offset, field_idx = pinr_lookup[exp_func]
                        macro_name = f"{pad_name}_{exp_func}"
                        lines.append(f"#define {macro_name}".ljust(32) + 
                                   f"SF32LB_PINMUX({port}, {pad_num}U, {select}U, 0x{offset:02X}U, {field_idx}U)")
            else:
                # Direct function (no PINR)
                # Skip GPIO_Axx as we already added GPIO
                if func.startswith('GPIO_'):
                    continue
                macro_name = f"{pad_name}_{func}"
                lines.append(f"#define {macro_name}".ljust(32) + 
                           f"SF32LB_PINMUX({port}, {pad_num}U, {select}U, 0U, 0U)")
        
        lines.append("")
    
    # Footer
    lines.append(f"#endif /* {guard} */")
    lines.append("")
    
    return '\n'.join(lines)


def generate_series_yaml(chip_yaml: dict, pinmux_data: dict, pinr_data: dict) -> str:
    """Generate series.yaml content with YAML anchors and aliases.
    
    This function generates the YAML string manually to properly handle
    anchors and aliases for pad references.
    """
    lines = []
    
    # Header
    lines.append(f"schema_version: {chip_yaml['schema_version']}")
    lines.append(f"model_id: {chip_yaml['model_id']}")
    lines.append(f"lifecycle: {chip_yaml['lifecycle']}")
    lines.append("")
    
    # Docs
    lines.append("docs:")
    for doc in chip_yaml['docs']:
        for doc_type, locales in doc.items():
            locale_parts = []
            for lang, url in locales.items():
                locale_parts.append(f'{lang}: "{url}"')
            lines.append(f"  - {doc_type}: {{{', '.join(locale_parts)}}}")
    lines.append("")
    
    # Pads with anchors
    lines.append("pads:")
    pinmux_map = pinmux_data.get('pinmux', {})
    
    for pad_name, pad_def in chip_yaml['pads'].items():
        # Add anchor
        lines.append(f"  {pad_name}: &{pad_name}")
        lines.append(f"    type: {pad_def['type']}")
        
        # Add description if present
        if 'description' in pad_def:
            lines.append(f"    description: \"{pad_def['description']}\"")
        
        # Add notes if present
        if 'notes' in pad_def:
            lines.append(f"    notes: \"{pad_def['notes']}\"")
        
        # Merge pinmux from shared file if available
        if pad_name in pinmux_map:
            lines.append("    functions:")
            for entry in pinmux_map[pad_name]:
                func = entry['function']
                has_pinr = entry.get('pinr', False)
                
                if has_pinr and pinr_data:
                    # Expand to specific signals
                    expanded = expand_pinr_functions(func, pinr_data)
                    for exp_func in expanded:
                        lines.append(f"      - {exp_func}")
                else:
                    # Direct function
                    lines.append(f"      - {func}")
    
    lines.append("")
    
    # Variants
    lines.append("variants:")
    first_pins_anchor = None
    
    for i, variant in enumerate(chip_yaml['variants']):
        lines.append(f"  - part_number: {variant['part_number']}")
        lines.append(f"    description: \"{variant['description']}\"")
        lines.append(f"    package: {variant['package']}")
        
        # Handle pins with anchor/alias
        pins = variant['pins']
        
        # Check if this variant uses an alias (has same pins as first variant)
        is_first_with_pins = first_pins_anchor is None
        if is_first_with_pins:
            # First variant with full pins definition - create anchor
            first_pins_anchor = f"{chip_yaml['model_id']}_QFN68_PINS"
            lines.append(f"    pins: &{first_pins_anchor}")
            for pin in pins:
                pad_name = pin['pad']
                lines.append(f"      - {{number: \"{pin['number']}\", pad: *{pad_name}}}")
        else:
            # Subsequent variant - use alias
            lines.append(f"    pins: *{first_pins_anchor}")
    
    lines.append("")
    return '\n'.join(lines)


def build_chip(chip_dir: Path, pinmux_dir: Path, output_dir: Path) -> bool:
    """Build series.yaml and pinctrl header for a single chip."""
    chip_yaml_path = chip_dir / "chip.yaml"
    series_yaml_path = output_dir / chip_dir.name / "series.yaml"
    
    if not chip_yaml_path.exists():
        print(f"  Skipping {chip_dir.name}: no chip.yaml found")
        return True
    
    print(f"  Building {chip_dir.name}...")
    
    # Load chip definition
    chip_data = load_yaml(chip_yaml_path)
    model_id = chip_data.get('model_id', chip_dir.name)
    
    # Load shared pinmux if specified
    pinmux_data = {}
    pinr_data = {}
    if 'shared_pinmux' in chip_data:
        pinmux_name = chip_data['shared_pinmux']
        pinmux_path = pinmux_dir / pinmux_name / "pinmux.yaml"
        pinr_path = pinmux_dir / pinmux_name / "pinr.yaml"
        
        if pinmux_path.exists():
            pinmux_data = load_yaml(pinmux_path)
            print(f"    Loaded shared pinmux: {pinmux_name}")
        else:
            print(f"    Warning: shared pinmux '{pinmux_name}' not found at {pinmux_path}")
        
        if pinr_path.exists():
            pinr_data = load_yaml(pinr_path)
            print(f"    Loaded PINR definitions: {pinmux_name}")
    
    # Generate series.yaml
    series_content = generate_series_yaml(chip_data, pinmux_data, pinr_data)
    with open(series_yaml_path, 'w', encoding='utf-8') as f:
        f.write(series_content)
    print(f"    Generated: {series_yaml_path}")
    
    # Generate Zephyr pinctrl header
    header_filename = f"{model_id.lower()}-pinctrl.h"
    header_path = output_dir / chip_dir.name / header_filename
    header_content = generate_pinctrl_header(model_id, pinmux_data, pinr_data)
    with open(header_path, 'w', encoding='utf-8') as f:
        f.write(header_content)
    print(f"    Generated: {header_path}")
    
    return True


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Build series.yaml files from chip.yaml and shared pinmux definitions"
    )
    parser.add_argument(
        "--chip", "-c",
        help="Build only the specified chip (directory name under chips/)",
        default=None
    )
    args = parser.parse_args()
    
    try:
        root = find_project_root()
    except RuntimeError as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1
    
    chips_dir = root / "chips"
    pinmux_dir = root / "common" / "pinmux"
    output_dir = root / "out"
    
    print(f"SiliconSchema Build")
    print(f"  Project root: {root}")
    print(f"  Chips directory: {chips_dir}")
    print(f"  Pinmux directory: {pinmux_dir}")
    print(f"  Output directory: {output_dir}")
    print()
    
    success = True
    
    if args.chip:
        # Build single chip
        chip_dir = chips_dir / args.chip
        if not chip_dir.exists():
            print(f"Error: chip directory '{args.chip}' not found", file=sys.stderr)
            return 1
        # Create output directory
        (output_dir / args.chip).mkdir(parents=True, exist_ok=True)
        success = build_chip(chip_dir, pinmux_dir, output_dir)
    else:
        # Build all chips
        print("Building all chips...")
        for chip_dir in sorted(chips_dir.iterdir()):
            if chip_dir.is_dir():
                # Create output directory
                (output_dir / chip_dir.name).mkdir(parents=True, exist_ok=True)
                if not build_chip(chip_dir, pinmux_dir, output_dir):
                    success = False
    
    print()
    if success:
        print("Build completed successfully!")
        return 0
    else:
        print("Build completed with errors.")
        return 1


if __name__ == "__main__":
    sys.exit(main())
